import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.feature import graycomatrix, graycoprops, local_binary_pattern
from sklearn.preprocessing import normalize
from concurrent.futures import ThreadPoolExecutor, as_completed
from google.colab import drive, files

drive.mount('/content/drive', force_remount=True)

dataset_dir = "/content/drive/MyDrive/images"
features_file = "features.npy"
paths_file = "paths.npy"


def preprocess_image(img_path, size=(256, 256)):
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"Cannot read {img_path}")
    img = cv2.resize(img, size, interpolation=cv2.INTER_AREA)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    return clahe.apply(img)


def extract_histogram_features(img, bins=64):
    hist = cv2.calcHist([img], [0], None, [bins], [0, 256])
    return cv2.normalize(hist, None).flatten()


def extract_glcm_features(img):
    glcm = graycomatrix(img, [1], [0, np.pi/4, np.pi/2, 3*np.pi/4],
                        levels=256, symmetric=True, normed=True)
    props = ['contrast', 'correlation', 'energy', 'homogeneity']
    return np.array([graycoprops(glcm, p).mean() for p in props])


def extract_lbp_features(img, P=8, R=1, bins=10):
    lbp = local_binary_pattern(img, P, R, method='uniform')
    hist, _ = np.histogram(lbp.ravel(), bins=bins, range=(0, bins))
    return cv2.normalize(hist.astype('float'), None).flatten()


def extract_statistical_features(img):
    mean, std, var = np.mean(img), np.std(img), np.var(img)
    return np.array([mean, std, var])


def extract_features(img_path):
    img = preprocess_image(img_path)
    f_hist = extract_histogram_features(img)
    f_glcm = extract_glcm_features(img)
    f_lbp = extract_lbp_features(img)
    f_stat = extract_statistical_features(img)
    return np.concatenate([f_hist, f_glcm, f_lbp, f_stat])


if os.path.exists(features_file) and os.path.exists(paths_file):
    feature_database = np.load(features_file)
    image_paths = np.load(paths_file)
else:
    image_paths = [os.path.join(dataset_dir, f) for f in os.listdir(dataset_dir)
                   if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
    feature_database = []

    with ThreadPoolExecutor(max_workers=8) as executor:
        futures = [executor.submit(extract_features, p) for p in image_paths]
        for f in as_completed(futures):
            try:
                feature_database.append(f.result())
            except Exception as e:
                print("Error:", e)

    feature_database = normalize(np.array(feature_database))
    np.save(features_file, feature_database)
    np.save(paths_file, np.array(image_paths))


def calculate_similarity(query_features, database_features):
    query_norm = np.sum(query_features ** 2)
    db_norms = np.sum(database_features ** 2, axis=1)
    dot_products = database_features @ query_features
    distances = np.sqrt(np.maximum(db_norms + query_norm - 2 * dot_products, 0))
    return distances


def retrieve_similar_images(query_path, top_k=5):
    query_features = extract_features(query_path)
    query_features = query_features / np.linalg.norm(query_features)
    distances = calculate_similarity(query_features, feature_database)
    top_indices = np.argsort(distances)[:top_k]

    fig, axes = plt.subplots(1, top_k + 1, figsize=(15, 3))
    query_img = preprocess_image(query_path)
    axes[0].imshow(query_img, cmap='gray')
    axes[0].set_title("Query Image")
    axes[0].axis('off')

    results = []
    for rank, idx in enumerate(top_indices, start=1):
        img = preprocess_image(image_paths[idx])
        axes[rank].imshow(img, cmap='gray')
        axes[rank].set_title(f"Rank {rank}\nDist: {distances[idx]:.4f}")
        axes[rank].axis('off')
        results.append((rank, image_paths[idx], distances[idx]))

    plt.tight_layout()
    plt.show()
    return results


print("Add a query test chest X-ray image")
query_uploaded = files.upload()
query_path = list(query_uploaded.keys())[0]

results = retrieve_similar_images(query_path, top_k=5)

print("\n Ranked Results:")
for rank, path, dist in results:
    print(f"Rank {rank}: {os.path.basename(path)} | Distance: {dist:.4f}")
